% lintrans - The linear transformation visualizer
% Copyright (C) 2021-2022 D. Dyson (DoctorDalek1963)

% This program is licensed under GNU GPLv3, available here:
% <https://www.gnu.org/licenses/gpl-3.0.html>

\documentclass[../development.tex]{subfiles}

\begin{document}

\subsubsection{Hiding the background and transformed grids\label{development:making-v0.2.2:hiding-the-background-and-transformed-grids}}

I spoke to my main stakeholder, who is the teacher that will be using \texttt{lintrans} when it's finished, and she said that the background grid and transformed grid can get a little bit in the way of the core action and make it harder to understand what's happening. Taking this feedback on board, I decided to add a display setting to toggle the background grid, and one to toggle the transformed grid.

I did the background grid first and then repeated everything for the transformed version of the grid as well. I am combining them here for brevity. The first step was of course to add a display setting for each of them. Then I had to add checkboxes for them in the display settings dialog, and then incorporate the settings into the actual drawing of the canvas.

%: d045057d568ac133b621ee9ca9daed361d570d7a
%: src/lintrans/gui/settings.py:14-27

%: d045057d568ac133b621ee9ca9daed361d570d7a
%: src/lintrans/gui/dialogs/settings.py:70,73,89-101,204,207-208,221,224-225 noscopes

%: d045057d568ac133b621ee9ca9daed361d570d7a
%: src/lintrans/gui/plots/widgets.py:60-63

%: d045057d568ac133b621ee9ca9daed361d570d7a
%: src/lintrans/gui/plots/classes.py:129-154

Then I added this change to the changelog.

%: d045057d568ac133b621ee9ca9daed361d570d7a
%: CHANGELOG.md:12-14 markdown!

\subsubsection{Hiding the basis vectors\label{development:making-v0.2.2:hiding-the-basis-vectors}}

While I was implementing new display settings, I decided to implement hiding basis vectors. This will give users the option of just seeing the grid get transformed. The process was exactly the same as before. Add the setting, add it to the dialog, use it when drawing.

%: 11ffbaf71f9fe29e1832a62f2b127aa3939e520d
%: src/lintrans/gui/settings.py:29-30

%: 11ffbaf71f9fe29e1832a62f2b127aa3939e520d
%: src/lintrans/gui/dialogs/settings.py:70,73,103-108,212,217,230,235 noscopes

%: 11ffbaf71f9fe29e1832a62f2b127aa3939e520d
%: src/lintrans/gui/plots/widgets.py:65-66

And then of course add it to the changelog.

%: 11ffbaf71f9fe29e1832a62f2b127aa3939e520d
%: CHANGELOG.md:12-14 markdown!

\subsubsection{Improving argument parsing\label{development:making-v0.2.2:improving-argument-parsing}}

Qt5 accepts arguments to its main method. I don't really know what these arguments can do, but it would be nice to be able to use them. I also want to be able to save sessions as files in the future, and it would be quite useful to open a session file by passing it as a command line argument. To make both of these easier, I decided to refactor my argument parsing.

Python has a built-in library called \pyinline{argparse}, which allows for more sophisticated argument parsing. One of the things \pyinline{argparse} can do is parse only some of the command line arguments with a method called \pyinline{parse_known_args()}\cite{argparse-parse-known-args}. I can then pass the unconsumed arguments on to Qt5. \texttt{\_\_main.py\_\_} now looks like this:

%: a688a14839caba2ee14f8551764b771ae803d935
%: src/lintrans/__main__.py

The \enquote{\pyinline{args[:1] + unparsed_args}} on line 71 means that we pass the name of the program first, and the rest of the unconsumed arguments after it.

And of course, I added it to the changelog, this time as a fix rather than an addition:

%: a688a14839caba2ee14f8551764b771ae803d935
%: CHANGELOG.md:16-18 markdown!

\subsubsection{Respecting display settings in the visual definition dialog\label{development:making-v0.2.2:respecting-display-settings-in-the-visual-definition-dialog}}

\texttt{DefineVisuallyWidget} is a subclass of \texttt{VisualizeTransformationWidget}. If it had its own instance attribute of type \pyinline{DisplaySettings}, then it could use its superclass's \pyinline{paintEvent()} method, and that would respect the display settings in the visual definition dialog.

%: 5850aa916b685992f31e58680267916927ed590d
%: src/lintrans/gui/plots/widgets.py:91-93

%: 5850aa916b685992f31e58680267916927ed590d
%: src/lintrans/gui/dialogs/define_new_matrix.py:169-180

Since the \texttt{DefineVisuallyDialog} now accepts display settings but the other definition dialogs don't, we need change the \pyinline{LintransMainWindow.dialog_define_matrix()} method to treat the visual definition dialog differently.

%: 5850aa916b685992f31e58680267916927ed590d
%: src/lintrans/gui/main_window.py:447-476

And, of course, I updated the changelog:

%: 5850aa916b685992f31e58680267916927ed590d
%: CHANGELOG.md:12,15 markdown!

\subsubsection{Changing the order in which things are drawn\label{development:making-v0.2.2:changing-the-order-in-which-things-are-drawn}}

Currently, \texttt{VisualizeTransformationWidget} draws the background, then the transformed grid, then the basis vectors, then the eigenlines and eigenvectors, then the determinant parallelogram and text. This means that the determinant parallelogram gets drawn on top of the basis vectors, which doesn't look very good. To fix this, we can simply re-order the drawing of different things. If we instead draw the transformed grid and basis vectors last, then they will appear on top of everything else, which should look significantly better.

I also renamed the \texttt{draw\_determinant\_text} display setting attribute to \texttt{show\_determinant\_value}.

Before:
%: e9da6737cbdb68e800c245bcc34e1c5c3824458a
%: src/lintrans/gui/plots/widgets.py:60-78

After:
%: acdf206a69d346dce67f74f2c54ff4c512c96229
%: src/lintrans/gui/plots/widgets.py:60-78

\begin{figure}[H]
	\hspace{0.03\linewidth}
	\begin{minipage}{0.45\linewidth}
		\begin{figure}[H]
			\centering
			\includegraphics[width=\linewidth]{development/5850aa916b685992f31e58680267916927ed590d/gui.png}
			\caption{Before re-ordering drawing commands}
			\label{fig:development:5850aa916b685992f31e58680267916927ed590d:gui.png}
		\end{figure}
	\end{minipage} \hfill
	\begin{minipage}{0.45\linewidth}
		\begin{figure}[H]
			\centering
			\includegraphics[width=\linewidth]{development/acdf206a69d346dce67f74f2c54ff4c512c96229/gui.png}
			\caption{After re-ordering drawing commands}
			\label{fig:development:acdf206a69d346dce67f74f2c54ff4c512c96229:gui.png}
		\end{figure}
	\end{minipage}
	\hspace{0.03\linewidth}
\end{figure}

\subsubsection{Improving online documentation with \textit{Read the Docs}\label{development:making-v0.2.2:improving-online-documentation-with-read-the-docs}}

So far, I've been building my documentation automatically using a tool called \texttt{Sphinx}\cite{sphinx}. I've been using it to scan through my source code, extract all the docstrings\cite{pep257-docstring-conventions}, and compile a HTML version of the source code documentation. I then publish this documentation to GitHub Pages\cite{github-pages-docs}, and all that happens automatically along with the unit tests whenever I push my changes to GitHub.

However, this system can't track changes in documentation over time. There's a popular website for hosting open source documentation, especially for Python packages, called \textit{Read the Docs}\cite{readthedocs-homepage}. It would be nice to host my documentation on there, since it would provide a standard build for the docs, and would allow me to keep track of documentation for different versions over time. I read through their tutorial and followed along with it, and then I could use Read the Docs for \texttt{lintrans}.

%: a7a8aa09148f4acf8591547d6d8b9cd8b8d52905
%: .readthedocs.yaml language=yaml

This file governs the build pipeline for the documentation. It defines how the docs will be built on the remote machine. It basically just installs all the dependencies and \texttt{lintrans} itself in a virtual environment, generates the object inventory for \texttt{intersphinx} (see \S\ref{development:preparing-for-v0.2.1:linking-in-documentation}), builds the internal import graph (see \S\ref{development:fumbling-with-semver:adding-a-graph-of-internal-imports}), and makes sure that lintrans can be installed successfully in the virtual environment. The string \enquote{\mintinline{sh}{$(pwd | sed "s/checkouts\(\/[^/]\+\)\/docs\$/envs\1/")/bin/python}} appears frequently. This string finds the version of Python that will be used for building the actual documentation at the end of the pipeline. \texttt{lintrans} has some issues with circular imports, which means that it can only be installed in editable mode\footnote{Editable mode is an option that you can choose when installing a package with \texttt{pip}\cite{pip-install-editable}. Instead of copying the source code to the installation directory like normal, it creates a link to the source code from the installation directory - basically a symlink in Linux. This means that if you change the source code, the installed version gets updated instantly, which is obviously very useful for fast, iterative development. It also has some strange effects with import order and resolution. Importing packages and modules is very complicated in Python\cite{david-beazley-python-modules}, and I repeatedly failed to get \texttt{lintrans} to be installable without editable mode, so I had to resort to just using this bodge on Read the Docs instead.}. This means that I have to bodge the build system to install \texttt{lintrans} properly.

Additionally, having a build system like this means that builds should be repeatable, which means I should pin the exact versions of all my dependencies, to avoid any breaking changes in the future.

%: 152f9e59b5b4e22607cf2b687c85c70708054579
%: requirements.txt language="lexers.py:CommentedTextLexer -x"

%: 152f9e59b5b4e22607cf2b687c85c70708054579
%: dev_requirements.txt language="lexers.py:CommentedTextLexer -x"

%: 152f9e59b5b4e22607cf2b687c85c70708054579
%: docs/docs_requirements.txt language="lexers.py:CommentedTextLexer -x"

Now that I was using Read the Docs, I could remove the old GitHub Actions workflow to compile the documentation.

\subsubsection{Parsing parentheses\label{development:making-v0.2.2:parsing-parentheses}}

\texttt{git} has a feature called branches\cite{git-docs-branch}, which allow you to work on different things simultaneously. A branch is basically a sandbox where you can make changes and focus on a particular feature while not having to worry about the rest of the project. It's particularly good for teams where different people can work on different features at the same time, but it's also useful for individual developers. The first feature branch I merged for \texttt{lintrans} was called \texttt{dev/parse-parens}. I created it a week or two ago, and I used it to focus on improving the parser to understand parenthesised expressions like \pyinline{"A(B+C)^2"}.

\paragraph{Extending validation\label{development:making-v0.2.2:parsing-parentheses:extending-validation}}

The first thing I needed to do was allow parenthesised expressions as valid. If the validator rejects them, then they can never be parsed. Any expression can be evaluated to a matrix, and a pair of balanced parentheses can contain any valid expression. As such, a parenthesised expression can be considered as a type of matrix.

%: 1e49c1479939b8de04751ab1a798afb2145b1550
%: docs/source/bnf.txt language="lexers.py:BnfHashtagCommentLexer -x"

%: 1e49c1479939b8de04751ab1a798afb2145b1550
%: src/lintrans/matrices/parse.py:16,23-118

We create a na誰ve character class that just contains all characters that could possibly be in a valid expression. Then when we compile the na誰ve expression pattern, we say that a matrix identifier can be one of three things: it can be a capital letter, the \texttt{rot()} command with a real number angle, or a balanced pair of parentheses around some characters. The characters in the parentheses are not validated at this stage (hence why this pattern is na誰ve), but we know that those characters are only allowed to be from the na誰ve character class.

Then we have a function that finds sub-expressions in a given expression. It simply scans through the given string with a pointer and keeps track of the current sub-expression. It uses the \pyinline{paren_depth} variable to keep track of how deep into a sub-expression it currently is. This function deliberately avoids counting the parentheses from \texttt{rot()} commands towards the \pyinline{paren_depth}. This is to avoid scanning an expression like \pyinline{"3rot(45)^2"} and finding \pyinline{"45"} as a sub-expression.

Then we have to actually use this function when validating. All we do is recursively check that each sub-expression is a valid expression on its own. The \pyinline{find_sub_expressions()} function only goes one level deep, so in an expression like \pyinline{"A(B+C(D^2-E))"}, it will only find \pyinline{"B+C(D^2-E)"} as a sub-expression, so recursion is needed to make the validation work properly.

There's actually a small mistake in the BNF that I didn't notice until much much later. The validation code is correct - it treats a parenthesised expression as a matrix identifier, so it can accept a multiplier on the left and an index on the right - but the BNF treats a parenthesised expression as a full matrix, which means it can't accept a multiplier or index. This doesn't affect the code, but does make the documentation slightly confusing.

And of course, I then added to the automatic unit tests to make sure this new validation worked.

%: 1e49c1479939b8de04751ab1a798afb2145b1550
%: tests/matrices/test_parse_and_validate_expression.py:16-30,33,50-52,54,57,60,70,105-111

I also added \pyinline{@pytest.mark.xfail} to \pyinline{test_parse_matrix_expression()}, since parsing should fail with the parenthesised expressions because I haven't implemented it yet.

\pytestScreenshot{1e49c1479939b8de04751ab1a798afb2145b1550}

\paragraph{Creating the parser class\label{development:making-v0.2.2:parsing-parentheses:creating-the-parser-class}}

I previously used regular expressions to parse matrix expressions. The algorithm would replace various parts of the expression to coerce it into the correct format, and then use a big RegEx at the end to find all the parts necessary for parsing. This was hard to understand and hard to maintain. It's now time to overhaul this parsing system and use a parser class to scan through the input and parse character-by-character, keeping track of the state as it goes.

%: 736809714e0ad7579c419db03c4b5d8b8fd0c1a1
%: src/lintrans/matrices/parse.py:122-351

The \pyinline{MatrixToken} class just holds data about a matrix multiplier, identifier, and exponent. It's just a simple way to package up this data into a single dataclass to keep track of which matrices we've parsed.

The \pyinline{ExpressionParser} class works like so: when you create a new instance, you give it an expression to parse and it cleans up the expression by removing whitespace, making sure it's valid, wrapping exponents with \texttt{\{\}}, etc. Most of these replacement steps are taken from the previous RegEx-based parser. It then sets up some internal state to keep track of the expression, the pointer, the token that it's currently parsing, the group that it's currently parsing, and its progress so far.

When you've created a new instance, you should call the public \pyinline{parse()} method, which will return the parsed expression at the end, in the same format that the old parser used. The \pyinline{parse_matrix_expression()} function is a wrapper that just creates an \pyinline{ExpressionParser} and calls \pyinline{parse()}.

The \pyinline{parse()} method itself just delegates to \pyinline{_parse_multiplication_group()}. A multiplication group is a group of matrices that will be multiplied together in a particular order. An expression should start with a multiplication group, and may have extra ones separated with plus signs. When all the multiplication groups have been parsed, it returns the final parse list.

\pyinline{_parse_multiplication_group()} tries to parse matrices until it reaches the end of the expression or it finds a plus sign, at which point it appends the current group to the final list and returns.

\pyinline{_parse_matrix()} returns a boolean to indicate success. It just attempts to parse a \enquote{matrix part} (multiplier, identifier, or exponent) until that fails, and then ensures that the resultant matrix token has a valid identifier. It then appends the matrix token to the current group.

\pyinline{_parse_matrix_part()} is where most of the selection happens. This method has to determine if it's looking at a multiplier, which would start with a digit or a minus sign; a normal identifier, which would start with a capital letter; a rotation identifier, which would start with a lowercase letter r; a sub-expression, which would start with an open bracket; or an exponent, with will start with a caret. If it encounters a plus sign, then that's a soft error, so it can return \pyinline{False}, but if it encounters something it doesn't recognise, then that's a hard error.

\pyinline{_parse_multiplier()} just parses a real number into \pyinline{self.current_token.multiplier}.

\pyinline{_parse_rot_identifier()} parses a \texttt{rot()} command with a real number angle\footnote{It doesn't need to parse the real number itself to make sure it's valid, since the expression validator already ensured that it was a valid real number.}.

\pyinline{_parse_sub_expression()} hasn't been implemented yet, but it will eventually parse sub-expressions, hence the name.

\pyinline{_parse_exponent()} parses a caret, and then a balanced pair of braces, containing an integer or a capital letter T.

And of course, this new parser should still pass all the unit tests for the previous parser, which it does.

% The tests haven't changed at all, so we can just use the previous image
\pytestScreenshot{1e49c1479939b8de04751ab1a798afb2145b1550}

\paragraph{Implementing sub-expression parsing\label{development:making-v0.2.2:parsing-parentheses:implementing-sub-expression-parsing}}

Of course, the next step was to actually implement sub-expression parsing. To do this, I used a very similar method to finding the sub-expressions, where I kept track of the depth of the parentheses. Except with this method, we only wanted the first sub-expression starting at the pointer. We can then assign this whole sub-expression to \pyinline{self.current_token.identifier} at the end.

Much like when finding sub-expressions, this parser method only goes one level deep, but the \pyinline{MatrixWrapper} will use recursion when evaluating the parsed expressions, so it will handle nested sub-expressions with.

%: 493f8cf3fb658408466f099f978d276fc2262243
%: src/lintrans/matrices/parse.py:305-332

\paragraph{Fixing little bugs\label{development:making-v0.2.2:parsing-parentheses:fixing-little-bugs}}

Since I've now implemented sub-expression parsing, I should be able to just remove the \pyinline{@pytest.mark.xfail} line from before and all the tests should pass with no problem.

\pytestScreenshot[One of the tests failing]{493f8cf3fb658408466f099f978d276fc2262243-noxfail}

Ah. That's not good. So what went wrong? Well, we can see from the output that \pyinline{test_parse_matrix_expression()} is the one that failed. This test iterates over a whole list, so which element broke it? Well, we can see from the line \enquote{\pyinline{self = lintrans.matrices.parse.ExpressionParser(".1A")}} that it was trying to parse the expression \pyinline{".1A"}. This doesn't work, not because \pyinline{ExpressionParser._parse_multiplier()} doesn't understand this type of multiplier, but because \pyinline{ExpressionParser._parse_matrix_part()} doesn't recognise a dot as the start of a multiplier, so never calls \pyinline{_parse_multiplier()}. This would be a very easy fix, but this error got me thinking about these multipliers and I decided to just forbid them. They can create confusion; \pyinline{"0.1A"} is easier to understand than \pyinline{".1A"}. Implementing this change just meant removing this type of multiplier from the tests.

Once I'd done that, the parser should work fine, right?

\pytestScreenshot[Another test failing]{9b1c69926c225574161d32dcbecd86055edb4065-noxfail}

Well, that's strange. It was trying to parse the expression \pyinline{"A 0.1B"} but it thought the \texttt{0.1} was part of the \texttt{A}. Why did that happen? Well, it's because of line 232 in this snippet:

%: 9b1c69926c225574161d32dcbecd86055edb4065
%: src/lintrans/matrices/parse.py:231-235 highlight=232

The parser parsed \pyinline{"A"} as the matrix identifier and then encountered \pyinline{"0"}. Since the current token didn't have a multiplier, it started parsing a multiplier for the matrix $\mathbf{A}$. To fix this, we can just fail to parse a matrix part if we encounter the start of a multiplier when the current token already has an identifier. Failing to parse a matrix part here means that the parser will start parsing a new matrix.

%: 8d7143fc33ea7bd4199e0f01b6a5308dfcf03ff9
%: src/lintrans/matrices/parse.py:231-236 highlight=232-233

That should fix the tests, right?

\pytestScreenshot[\textit{Another} test failing]{9b1c69926c225574161d32dcbecd86055edb4065-noxfail-fixed-mul-order}

I'm getting tired of this now. What's broken this time? Well, the parser processes its input to remove whitespace and add braces around exponents before any parsing takes place. This includes processing the contents of sub-expressions. That was never a problem before, since parsing wasn't affected by whitespace or braces, but now those changes propagate into the sub-expressions. I wrote the sub-expression parsing tests in \S\ref{development:making-v0.2.2:parsing-parentheses:extending-validation} by using my literal expression input in the parsed sub-expressions. So to fix this error, I just had to account for the syntax transformations in the test input.

\textit{Now} the tests should all pass, right?

\pytestScreenshot[All the tests finally passing]{8d7143fc33ea7bd4199e0f01b6a5308dfcf03ff9}

Thank god.

\paragraph{Making recursive evaluation work\label{development:making-v0.2.2:parsing-parentheses:making-recursive-evaluation-work}}

When \pyinline{MatrixWrapper.__getitem__()} tries to retrieve a matrix which is defined in terms of an expression, it has to call \pyinline{MatrixWrapper.evaluate_expression()}. This method in turn calls \pyinline{__getitem__()} again to evaluate the matrices used in the expression. Now that sub-expressions exist, \pyinline{__getitem__()} might get called with a sub-expression identifier, so it needs to be able to evaluate these expressions. To do this, we can simply add another call to \pyinline{evaluate_expression()}, as seen on lines 120-121.

%: ba1ee72fcafd5129aed76992f743e5966f5c199d
%: src/lintrans/matrices/wrapper.py:100-131,214-248 highlight=120-121

I then added a new unit test function to make sure parenthesised expressions get evaluated properly.

%: ba1ee72fcafd5129aed76992f743e5966f5c199d
%: tests/matrices/matrix_wrapper/test_evaluate_expression.py:229-257

\pytestScreenshot{ba1ee72fcafd5129aed76992f743e5966f5c199d}

I also improved the doctests for \pyinline{parse_matrix_expression()} by adding a case for these new parenthesised expressions, and I added a doctest for the expression parser.

%: e3d633133f293fc1308d6fc0c60a1febaf67dda0
%: src/lintrans/matrices/parse.py:349-373 highlight=366-367

%: bf1f5a1eaac60d23964a44c9a6b8235c5e0fcab2
%: src/lintrans/matrices/parse.py:136-147

\pytestScreenshot[Running \texttt{pytest} with the new and improved doctests]{bf1f5a1eaac60d23964a44c9a6b8235c5e0fcab2}

And of course, I updated the changelog:

%: 9e26079475e33f3ab2e02e76ea59a66217d18f76
%: CHANGELOG.md:12,16 markdown!

\paragraph{Ensuring numerical formats\label{development:making-v0.2.2:parsing-parentheses:ensuring-numerical-formats}}

The validation checks the format of the numbers in multipliers, exponents and \texttt{rot()} commands, but it would be quite good to also validate the format of these numbers when parsing, just to make absolutely sure that they will be able to be correctly evaluated. To do this, we can simply perform the conversion in a try/except block. It would also be good to validate the sub-expressions.

%: 761c6ed255ed65c3396c6a551acfa60bb7485a17
%: src/lintrans/matrices/parse.py:282-372 highlight=295-298,310-314,348-349,363-367

\subsubsection{Fixing premature \texttt{rot()} evaluation\label{development:making-v0.2.2:fixing-premature-rot-evaluation}}

Now that parenthesised expressions are done, I can focus on other improvements.

When playing around with this new feature, I discovered a bug where an expression like \pyinline{"rot(45)^2"} would be evaluated in the same way as \pyinline{"rot(45)"}. After lots of confusion and debugging, I discovered that this bug was in \pyinline{MatrixWrapper.__getitem__()} when it tries to evaluate \texttt{rot()} commands. It does this by eagerly searching for the \texttt{rot()} RegEx in the string. This was never an issue before, but now that this method might get called with a whole expression, this RegEx can trigger too early. If it's given an expression which contains a \texttt{rot()} command anywhere in it, then it will return a rotation matrix immediately. To fix this, we just have to ensure that the \texttt{rot()} command takes up the whole string before returning a rotation matrix. We can do this by anchoring the RegEx with \texttt{\textasciicircum} and \texttt{\$}.

%: c23d540aa3b8df91b9478fb113cb42df4c7d5e42
%: src/lintrans/matrices/wrapper.py:115-131 highlight=116

I also added cases to the parenthesised expressions test to cover this change.

%: c23d540aa3b8df91b9478fb113cb42df4c7d5e42
%: tests/matrices/matrix_wrapper/test_evaluate_expression.py:243-247

And then added it to the changelog.

%: c23d540aa3b8df91b9478fb113cb42df4c7d5e42
%: CHANGELOG.md:18,21 markdown!

\subsubsection{Animating rotations\label{development:making-v0.2.2:animating-rotations}}

% TODO: Video?
When animating a rotation like \pyinline{"rot(170)"}, it animates a rotation of $170\degree$, but it doesn't look very good. I fixed an old rotation issue in \S\ref{development:visualizing-matrices:preserving-determinants}, but the speed is still a problem.

The speed of rotation is significantly higher during the middle of the rotation, which makes it look unnatural. I want to fix this to make rotations look more natural. Ideally, the program would detect a rotation and animate it in a different way, by moving the tips of the basis vectors along the edge of a circle with the radius equal to the length of the basis vectors. That shouldn't be too hard. However, I'd also like to animate scaled rotations like \pyinline{"2rot(170)"}. Animating in a circle won't work for this type of transformation, so I'll need to use a spiral.

This is a big feature, so I split it into a \texttt{dev/anim-rot} branch.

\paragraph{Factoring out animation frames\label{development:making-v0.2.2:animating-rotations:factoring-out-animation-frames}}

The \pyinline{LintransMainWindow.animate_expression()} method obviously handles animating expressions. It does this by calling a separate method called \pyinline{LintransMainWindow.animate_between_matrices()} after parsing and evaluating the expression. The first step of improving my rotational animation code is to factor out the generation of individual frames when animating between matrices. This separate method will make it easier to work on the new feature.

Here's the old code, including the \pyinline{animate_expression()} method, which wasn't changed:

%: 751f185a2b64d31fe7ddd53aafab110008cff50b
%: src/lintrans/gui/main_window.py:376-445

And here's the new code, not including the unchanged \pyinline{animate_expression()} method:

%: d47bb0165304d496caf7bbe3e09e4bbd12e45453
%: src/lintrans/gui/main_window.py:376-462 highlight=394

Notice the \texttt{if} statement on line 394. This checks if the determinant is positive and the dot product of the basis vectors is close to 0. If these are both true, then the application matrix is a rotation matrix\footnote{This isn't actually true. An enlargement matrix would also satisfy these conditions, but I didn't realise that at the time.\label{footnote:not-only-a-rotation-matrix}}.

\paragraph{Utility functions and logarithmic spirals\label{development:making-v0.2.2:animating-rotations:utility-functions-and-logarithmic-spirals}}

I moved the \pyinline{create_rotation_matrix()} function from \texttt{lintrans.matrices.wrapper} to a new \texttt{lintrans.matrices.utility} module, which will contain utility functions to help with animating rotations. And for the sake of consistency, I decided to only care about positive angles, so I adapted the function to make all angles positive by taking them modulo $360\degree$ or $2\pi$ radians.

I also added some other utility functions - \pyinline{polar_coords()} and \pyinline{rect_coords()} - which will convert rectilinear (Cartesian) coordinates to polar coordinates and back again, respectively.

%: 183dd02b4194c93aad51a21b7ad4147418c387c5
%: src/lintrans/matrices/utility.py

I then added unit tests for these functions and to assert that \pyinline{create_rotation_matrix()} always makes its angle positive.

%: 7b0c374d586e487e547dad886cc24239f768b554
%: tests/matrices/utility/test_coord_conversion.py

%: 7b0c374d586e487e547dad886cc24239f768b554
%: tests/matrices/utility/test_rotation_matrices.py:74-86 highlight=83-86

\pytestScreenshot{7b0c374d586e487e547dad886cc24239f768b554}

Then I had to actually implement the logarithmic spiral. I spent several hours playing around with Desmos and various formulae on paper, and eventually devised a way to connect two points with a logarithmic spiral. Sometimes.

The formula I came up with was designed to give a polar coordinate $(r, \theta)$ which was some proportion $p$ between 0 and 1 along the logarithmic spiral connecting the polar coordinates $(r_1, \theta_1)$ and $(r_2, \theta_2)$. A generic logarithmic spiral has the form $r = b^\theta$, where $b$ is called the base. I came up with the following equations to define my connecting curve:
$$r = r_1 \times b^{(\theta - \theta_1)}\ \ \ \ \ \text{where } b = \left(\frac{r_2}{r_1}\right)^{\frac{-1}{\theta_1 - \theta_2}}$$

To get an arbitrary point with a proportion $p$ along the curve, you can find $\theta$ by $\theta = \theta_1 + p(\theta_2 - \theta_1)$ and then plug that back in to find $r$.

Then I just had to implement this formula in code to move each basis vector accordingly.

%: 2c86b3a7f40deb760e852fe6d0213cba15afcf9e
%: src/lintrans/gui/main_window.py:388-425

It worked really well for simple rotations like \pyinline{"rot(170)"} and even worked for \pyinline{"2rot(180)"}, which I was very happy with. However, if you start from $\mathbf{I}$, which is the default starting position, and try to rotate any more than $270\degree$, the $i$ vector goes anticlockwise, and the $j$ vector goes clockwise. If you start at $\mathbf{I}$ and try to animate \pyinline{"rot(180)"} more than once, then any time after the first, the basis vectors will rotate in opposite directions and go through each other. Even though after applying \pyinline{"rot(180)"} twice, you should be back to $\mathbf{I}$, the floating point error adds up and that tiny deviation breaks it.

This approach was a good start, but I'm going to need something better.

\paragraph{Checking for enlargement matrices\label{development:making-v0.2.2:animating-rotations:checking-for-enlargement-matrices}}

I found a bug where any enlargement matrix would immediately crash the program when you tried to animate. Suffice it to say, that's not very good. Recall back to footnote~\ref{footnote:not-only-a-rotation-matrix}, where I said that the check would count enlargement matrices as rotation matrices. The logarithmic spiral formula can't connect two points with the same angle, since it would end up dividing by zero to find the base. This, of course, results in a crash.

To fix this bug, I simply changed the check to ignore any matrix that looks like an enlargement. If you divide an enlargement matrix by its determinant, then it will look like $\mathbf{I}$, so we can just check that. Additionally, I only want to animate rotations smoothly like this if the smoothen determinant setting is on.

%: 31100f35e8d46fcddaad18ee801e28904dc3011d
%: src/lintrans/gui/main_window.py:395-398 highlight=395,398

\paragraph{Using incremental circles instead\label{development:making-v0.2.2:animating-rotations:using-incremental-circles-instead}}

The logarithmic spiral was a nice idea, but the instability made it unsuitable as a long term solution. Instead, I decided to use incremental circles instead. I would scale a radius according the start and end radii, as well as the proportion of the way through the animation. Then I would find an angle in the same way and combine them into one polar coordinate.

Also, if the starting matrix is singular, then NumPy can't invert it so it crashes. This is obviously also bad, so I just had to check for it.

%: f97f6542a051c05896711a01eb48a04dba693f64
%: src/lintrans/gui/main_window.py:388-432

Does this solve the instability problem with the basis vectors rotating in opposite directions? No. Does it make this algorithm simpler and easier to improve? Yes.

\paragraph{Treating the rotation as one thing\label{development:making-v0.2.2:animating-rotations:treating-the-rotation-as-one-thing}}

\begin{figure}[H]
	\begin{minipage}{0.45\linewidth}
		\begin{tikzpicture}
			\coordinate (O) at (0, 0);
			\coordinate (A) at (1, 0);
			\coordinate (I) at (30:3);
			\coordinate (J) at (120:3);

			\draw (0, -1) -> (0, 3.5);
			\draw (-3.5, 0) -> (3.5, 0);
			\draw (O) -> (I);
			\draw (O) -> (J);

			\tkzMarkAngle(A,O,I);
			\tkzLabelAngle[pos=0.75](A,O,I){$\theta$};
		\end{tikzpicture}
	\end{minipage}\hfill
	\begin{minipage}{0.5\linewidth}\setspacing
		After much thought and deliberation, I realised that my fatal error was rotating the basis vectors independently. This allowed small floating point errors to cause the basis vectors to be rotated in opposite directions. What I need to do instead was to find the angle from one basis vector, and use that to rotate both.

		I can find the angle $\theta$ by using the first column of the application matrix, and then rotate both basis vectors by this same angle. By finding the angle just once and using a dedicated \pyinline{rotate_coord()} utility function to avoid converting back and forth, it ensures that both the basis vectors get rotated by the same angle in the same direction.
	\end{minipage}
	\vspace{-1em}
\end{figure}

I first added a type alias for a vector, mainly for convenience.

%: c228904ab61cb33a6581fe28bbd6330b5c2ece97
%: src/lintrans/typing_/__init__.py:27-28

I then created a utility function to rotate a rectilinear coordinate by a given angle.

%: 425f3d653770724a01fd5f94314c7d076dadfef2
%: src/lintrans/matrices/utility.py:43-51

Then when generating a frame, I normalise the angle $\theta$ to be $-\pi \leq \theta < \pi$ (radians) and then rotate the coordinates of each basis vector by a proportion of the angle for each frame in the animation.

%: 425f3d653770724a01fd5f94314c7d076dadfef2
%: src/lintrans/gui/main_window.py:377-424

And of course, I added this to the changelog.

%: 425f3d653770724a01fd5f94314c7d076dadfef2
%: CHANGELOG.md:12,16 markdown!

Now rotations finally work properly!

\subsubsection{Adding a setting for animation time\label{development:making-v0.2.2:adding-a-setting-for-animation-time}}

Once I'd merged the \texttt{dev/anim-rot} branch, I was basically done with \texttt{v0.2.2}, but I still wanted to add one last thing. I already had a display setting to control the delay between animating consecutive matrices in a sequence, but I also wanted a display setting to control how long the actual animation lasts. This would allow a teacher to animate something slowly to more precisely show an animation. Implementing it was very simple.

I just had to add the setting to the \pyinline{DisplaySettings} dataclass, add code to the display settings dialog to allow changing it, and then use it in animations.

%: 86343c4b0dd4ed9052184fd4ed924062a1cd9264
%: src/lintrans/gui/settings.py:51-52

%: 86343c4b0dd4ed9052184fd4ed924062a1cd9264
%: src/lintrans/gui/dialogs/settings.py:21,24,127-134,226,236,245,255 noscopes

%: 86343c4b0dd4ed9052184fd4ed924062a1cd9264
%: src/lintrans/gui/main_window.py:465-493 highlight=471,491

And then finally, I added it to the changelog.

%: 86343c4b0dd4ed9052184fd4ed924062a1cd9264
%: CHANGELOG.md:10,16 markdown!

\subsubsection{Releasing \texttt{v0.2.2}\label{development:making-v0.2.2:releasing-v0.2.2}}

Now I can just update the version number, tag the commit, and let GitHub Actions do the rest.

%: 1139f94366be359aa5606c750c67b72c2777c961
%: src/lintrans/__init__.py:11

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\linewidth]{development/1139f94366be359aa5606c750c67b72c2777c961/release.png}
	\caption{The release of \texttt{v0.2.2} on GitHub}
	\label{fig:development:1139f94366be359aa5606c750c67b72c2777c961:release.png}
\end{figure}

\end{document}
